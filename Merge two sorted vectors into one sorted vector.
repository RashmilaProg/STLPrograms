How to Merge Two Sorted Vector in C++?
Last Updated : 23 Jul, 2025
Merging two sorted vectors means storing the elements of a vector into a single vector in a sorted order. In this article, we will learn how to merge two sorted vectors in C++.

The simplest way to merge the two sorted vectors is by using the merge() function.  Let’s take a look at an example:

#include <bits/stdc++.h>
using namespace std;
​
int main() {
    vector<int> v1 = {1, 3, 5};
    vector<int> v2 = {2, 4, 6};
​
    // Creating a vector to store merged vector
    vector<int> v(v1.size() + v2.size());
​
    // Merging the two vectors
    merge(v1.begin(), v1.end(), v2.begin(),
          v2.end(), v.begin());
​
    for (auto i : v)
        cout << i << " ";
    return 0;
}

Output
1 2 3 4 5 6 
Explanation: The merge() function merge the two vectors v1 and v2 in sorted manner and store it in the resultant vector v.

There are also some other methods in C++ to merge the two sorted vector. Some of them are as follows:

By Sorting After Concatenation
Copy both the vectors into resultant vector using vector insert() method. After that, sort the resultant using sort() to arrange the elements in sorted order.




#include <bits/stdc++.h>
using namespace std;
​
int main() {
    vector<int> v1 = {1, 3, 5};
    vector<int> v2 = {2, 4, 6};
​
    // Creating a vector to store the merged vector
    vector<int> v;
​
    // Insert v1 and v2 into vector v
    v.insert(v.end(), v1.begin(), v1.end());
    v.insert(v.end(), v2.begin(), v2.end());
​
    // Sort the vector v
    sort(v.begin(), v.end());
​
    for (auto i : v)
        cout << i << " ";
    return 0;
}

Output
1 2 3 4 5 6 
Using Multiset
A multiset stores its elements in a sorted order by default. It can be used as a temporary storage medium to combine the elements of both vectors while maintaining sorted order, and then transfer all the elements into the resultant vector.




#include <bits/stdc++.h>
using namespace std;
​
int main() {
    vector<int> v1 = {1, 3, 5};
    vector<int> v2 = {2, 4, 6};
​
    // Insert elements of v1 and v2 into multiset
    multiset<int> ms(v1.begin(), v1.end());
    ms.insert(v2.begin(), v2.end());
​
    // Copying elements of multiset into vector v
    vector<int> v(ms.begin(), ms.end());
​
    for (auto i : v)
        cout << i << " ";
    return 0;
}

Output
1 2 3 4 5 6 


To merge two sorted vectors into one, the optimal approach is to use a two-pointer technique, similar to the merge step in Merge Sort. This involves creating a new, larger vector and then simultaneously traversing the two input vectors with pointers, picking the smaller element at each step and adding it to the new vector until both input vectors are exhausted. 
cpp
#include <vector>
#include <algorithm> // For std::sort if you use the naive approach

// Optimal approach using two pointers
std::vector<int> mergeSortedVectorsOptimal(const std::vector<int>& v1, const std::vector<int>& v2) {
    std::vector<int> merged;
    merged.reserve(v1.size() + v2.size()); // Reserve space to avoid reallocations

    auto it1 = v1.begin();
    auto it2 = v2.begin();

    while (it1 != v1.end() && it2 != v2.end()) {
        if (*it1 < *it2) {
            merged.push_back(*it1);
            ++it1;
        } else {
            merged.push_back(*it2);
            ++it2;
        }
    }

    // Add any remaining elements from v1
    while (it1 != v1.end()) {
        merged.push_back(*it1);
        ++it1;
    }

    // Add any remaining elements from v2
    while (it2 != v2.end()) {
        merged.push_back(*it2);
        ++it2;
    }

    return merged;
}

// Naive approach: Concatenate and sort
std::vector<int> mergeSortedVectorsNaive(const std::vector<int>& v1, const std::vector<int>& v2) {
    std::vector<int> merged = v1;
    merged.insert(merged.end(), v2.begin(), v2.end()); // Concatenate v2 to v1
    std::sort(merged.begin(), merged.end()); // Sort the combined vector
    return merged;
}

/*
// Example Usage (in a main function)
#include <iostream>

int main() {
    std::vector<int> vec1 = {1, 3, 5, 7};
    std::vector<int> vec2 = {2, 4, 6, 8, 10};

    // Using the optimal approach
    std::vector<int> result_optimal = mergeSortedVectorsOptimal(vec1, vec2);
    std::cout << "Merged (Optimal): ";
    for (int x : result_optimal) {
        std::cout << x << " ";
    }
    std::cout << std::endl; // Output: Merged (Optimal): 1 2 3 4 5 6 7 8 10

    // Using the naive approach
    std::vector<int> result_naive = mergeSortedVectorsNaive(vec1, vec2);
    std::cout << "Merged (Naive): ";
    for (int x : result_naive) {
        std::cout << x << " ";
    }
    std::cout << std::endl; // Output: Merged (Naive): 1 2 3 4 5 6 7 8 10

    return 0;
}
*/
Optimal Approach (Two Pointers) 
Create a Result Vector: Initialize an empty vector, merged, to store the result.
Initialize Pointers: Use two iterators or indices, it1 and it2, pointing to the beginning of the first and second input vectors, respectively.
Compare and Add: While both it1 and it2 are within their respective vector bounds:
Compare the elements pointed to by it1 and it2.
Add the smaller element to the merged vector and advance the corresponding pointer.
Add Remaining Elements: After one vector is exhausted, add all remaining elements from the other vector to merged. 
Naive Approach (Concatenate and Sort)
Concatenate: Create a new vector by appending all elements of the second vector to the end of the first vector.
Sort: Sort the combined vector using a standard sorting algorithm. 
